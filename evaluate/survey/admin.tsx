import * as React from 'react';
import { render, findDOMNode } from 'react-dom';
import * as mobx from 'mobx';
import { observable } from 'mobx';
import * as mobxReact from 'mobx-react';
import * as io from 'socket.io-client';
import * as common from './common';
import 'whatwg-fetch'
import { Session, NetRating } from './db';
import * as ReactPivot from 'react-pivot';

@mobxReact.observer
class Component extends React.Component<{}, {}> {

}
const initialReduced = {
    ratingTotal: 0,
    ratingCount: 0,
    naturalnessCount: 0,
    naturalnessTotal: 0,
    timingCount: 0,
    timingTotal: 0
};

type Reduced = typeof initialReduced;

class TPivot extends ReactPivot<NetRating, Reduced> { }

function copyToClipboard(text: string) {
    var textarea = document.createElement("textarea");
    textarea.textContent = text;
    textarea.style.position = "fixed";  // Prevent scrolling to bottom of page in MS Edge.
    document.body.appendChild(textarea);
    textarea.select();
    try {
        return document.execCommand("copy");  // Security exception may be thrown by some browsers.
    } catch (ex) {
        console.warn("Copy to clipboard failed.", ex);
        return false;
    } finally {
        document.body.removeChild(textarea);
    }
}

class GUI extends Component {
    @observable.ref
    data: NetRating[] | null = null;
    @observable.ref
    sessions: Session[] | null = null;
    @observable aliasSamples = true;
    @observable hideOverwritten = true;
    table: TPivot;
    constructor() {
        super();
        this.load();
    }
    async load() {
        let url1 = location.protocol + "//" + location.hostname + ":8001" + location.pathname;
        let url = location.protocol + "//" + location.hostname + ":8001" + location.pathname + "ratings.json";
        url += "?" + Math.random();
        this.data = await (fetch("ratings.json").then(resp => resp.json()) as any);
        this.sessions = await (fetch("sessions.json").then(resp => resp.json()) as any);
    }
    reduce(row: NetRating, reduced: Reduced) {
        if (!reduced.ratingCount) Object.assign(reduced, initialReduced);
        reduced.ratingTotal += row.rating!;
        reduced.ratingCount += 1;
        if(row.ratingType === "naturalness") {
            reduced.naturalnessTotal += row.rating!;
            reduced.naturalnessCount += 1;
        }
        if(row.ratingType === "timing") {
            reduced.timingTotal += row.rating!;
            reduced.timingCount += 1;
        }
        return reduced;
    }
    timeTaken(session: Session) {
        const created = new Date(session.created);
        const key = (rating: NetRating) => new Date(rating.created).getTime();
        const data = this.data!.filter(rating => rating.session.id === session.id).sort((a, b) => key(b) - key(a));
        if (data.length > 0)
            return (key(data[0]) - created.getTime()) / 1000;
        else return 0;
    }
    toLatex() {
        function directTextBelow(node: Element) {
            return Array.from(node.childNodes).filter(node => node.nodeType === Node.TEXT_NODE).map(node => node.textContent).join("");
        }
        function textInFirstSpan(node: Element) {
            return node.children.length > 0 ? node.children[0].textContent || "average" : "";
        }
        function highlightAverages(row: string[]) {
            if(row.indexOf("average") >= 0) {
                if(row[0] === "truthrandom") row[0] = "truth";
                return row.map(x => `\\bf{${x}}`);
            }
            return row;
        }
        const div = findDOMNode(this.table);
        const tbl = div.getElementsByTagName("table")[0];
        const head = tbl.getElementsByTagName("thead")[0];
        const headThings = Array.from(head.children, tr => Array.from(tr.children, th => directTextBelow(th)));
        const body = tbl.getElementsByTagName("tbody")[0];
        let bodyThings = Array.from(body.children, tr => Array.from(tr.children, td => textInFirstSpan(td)));
        bodyThings = bodyThings.map(row => highlightAverages(row));
        // hack
        const hline = String.raw`\noalign{\smallskip}\hline\noalign{\smallskip}`;
        function withHlineBefore(arr: string[][]) {
            arr[0][0] = hline + "\n" + arr[0][0];
            return arr;
        }
        bodyThings = [
            ...bodyThings.slice(7, 14),
            ...withHlineBefore(bodyThings.slice(0, 7)),
            ...withHlineBefore(bodyThings.slice(14, 21)),
        ];
        return String.raw`
            % generated by
            % backchannel-prediction/evaluate/survey/admin.tsx
            % (${location.href})
            \begin{tabular}{${"c".repeat(headThings[0].length)}}
            \hline\noalign{\smallskip}
            ${headThings.map(row => row.join(" & ")).join(" \\\\\n")} \\
            \noalign{\smallskip}\svhline\noalign{\smallskip}
            ${bodyThings.map(row => row.join(" & ")).join(" \\\\\n")} \\
            \noalign{\smallskip}\hline\noalign{\smallskip}
            \end{tabular}
        `.split("\n").map(line => line.trim()).join("\n").trim();
    }
    nameOrId(row: NetRating) {
        const info = common.getPredictor(row.segment);
        if(this.aliasSamples) return info.preferredId + 1;
        else return info.sampletime;
    }
    render() {
        if (!this.data) return <div>Loading...</div>;
        let data = this.data;
        if(this.hideOverwritten) data = data.filter(rating => rating.final);
        return (
            <div>
                <p><button onClick={() => this.load()}>Reload</button></p>
                <label>Show sample names as ID
                    <input type="checkbox" checked={this.aliasSamples} onChange={() => this.aliasSamples = !this.aliasSamples} />
                </label>
                <label>Hide overwritten
                    <input type="checkbox" checked={this.hideOverwritten} onChange={() => this.hideOverwritten = !this.hideOverwritten} />
                </label>
                <button onClick={() => copyToClipboard(this.toLatex())}>Copy as LaTeX table</button>
                <TPivot key={`pivot al=${this.aliasSamples} hi=${this.hideOverwritten}`} ref={t => this.table = t}
                    rows={data}
                    dimensions={[
                        { value: row => row.session.id, title: 'Session ID' },
                        { value: row => common.getPredictor(row.segment).type, title: 'Predictor' },
                        { value: row => row.ratingType, title: 'Rating Type' },
                        { value: row => this.nameOrId(row), title: 'Sample' },
                        ...(!this.hideOverwritten ? [{ value: (row: NetRating) => !row.final, title: 'wasOverwritten' }] : [])
                    ]}
                    reduce={this.reduce}
                    activeDimensions={[
                        ...(!this.hideOverwritten ? ["wasOverwritten"] : []),
                        "Predictor",
                        "Sample"
                    ]}
                    sortBy="Sample"
                    hiddenColumns={["Average Rating", "Rating Count"]}
                    solo={this.hideOverwritten ? undefined : { title: "wasOverwritten", value: "false" }}
                    calculations={[
                        {
                            title: 'Average Rating',
                            value: row => row.ratingTotal / row.ratingCount,
                            template: (val, row) => {
                                return val.toPrecision(3) + ` points`;
                            }
                        },
                        {
                            title: 'Timing',
                            value: row => row.timingTotal / row.timingCount,
                            template: (val, row) => {
                                return val.toPrecision(3) + ` points`;
                            }
                        },
                        {
                            title: 'Naturalness',
                            value: row => row.naturalnessTotal / row.naturalnessCount,
                            template: (val, row) => {
                                return val.toPrecision(3) + ` points`;
                            }
                        },
                        {
                            title: 'Sample Size',
                            value: row => (row.naturalnessCount + row.timingCount) / 2,
                            template: (val, row) => val
                        },
                        /*{
                            title: 'Rating Count', value: (row: Reduced) => row.ratingCount,
                        }*/
                    ]}
                />
                <table>
                    <thead>
                        <tr><th>Session ID</th><th>Created</th><th>Time taken</th><th>Comment</th><th>IP</th><th>Agent</th></tr>
                    </thead>
                    <tbody>
                        {this.sessions && this.sessions.map(session =>
                            <tr key={session.id}>
                                <td>{session.id}</td>
                                <td>{session.created}</td>
                                <td>{this.timeTaken(session)}</td>
                                {/*<td>{JSON.stringify(session.handshake, null, 3)}</td>*/}
                                <td>{session.comment}</td>
                                <td>{(session.handshake as any)['address']}</td>
                                <td>{(session.handshake as any)['headers']['user-agent']}</td>
                            </tr>
                        )}
                    </tbody>
                </table>
            </div>
        )
    }
}


Object.assign(window, { gui: render(<GUI />, document.getElementById("app")) });
